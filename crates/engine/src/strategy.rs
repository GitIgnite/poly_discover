//! RSI-based backtesting strategy

use ta::indicators::RelativeStrengthIndex;
use ta::Next;
use tracing::debug;

use crate::types::Kline;

/// Signal generated by the RSI strategy
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Signal {
    Buy,
    Sell,
    Hold,
}

/// RSI strategy for backtesting
pub struct RsiStrategy {
    rsi: RelativeStrengthIndex,
    overbought: f64,
    oversold: f64,
    last_rsi: Option<f64>,
}

impl RsiStrategy {
    /// Create a new RSI strategy
    ///
    /// # Arguments
    /// * `period` - RSI lookback period (default: 14)
    /// * `overbought` - Overbought threshold (default: 70.0)
    /// * `oversold` - Oversold threshold (default: 30.0)
    pub fn new(period: usize, overbought: f64, oversold: f64) -> Self {
        Self {
            rsi: RelativeStrengthIndex::new(period).expect("Invalid RSI period"),
            overbought,
            oversold,
            last_rsi: None,
        }
    }

    /// Process a kline and return a trading signal
    pub fn on_bar(&mut self, kline: &Kline) -> Signal {
        // Convert close price to f64 for the ta crate
        let close_f64 = kline.close.to_string().parse::<f64>().unwrap_or(0.0);
        let rsi_value = self.rsi.next(close_f64);
        self.last_rsi = Some(rsi_value);

        if rsi_value < self.oversold {
            debug!(
                rsi = rsi_value,
                threshold = self.oversold,
                "RSI oversold → BUY signal"
            );
            Signal::Buy
        } else if rsi_value > self.overbought {
            debug!(
                rsi = rsi_value,
                threshold = self.overbought,
                "RSI overbought → SELL signal"
            );
            Signal::Sell
        } else {
            Signal::Hold
        }
    }

    /// Get the last computed RSI value
    pub fn last_rsi(&self) -> Option<f64> {
        self.last_rsi
    }
}
